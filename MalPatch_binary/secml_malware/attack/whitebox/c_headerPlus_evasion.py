import struct
import numpy as np
import torch
from secml.settings import SECML_PYTORCH_USE_CUDA

from secml_malware.attack.whitebox.c_fast_gradient_sign_evasion import CFastGradientSignMethodEvasion
from secml_malware.attack.whitebox.c_discretized_bytes_evasion import CDiscreteBytesEvasion
from secml_malware.models import CClassifierEnd2EndMalware

use_cuda = torch.cuda.is_available() and SECML_PYTORCH_USE_CUDA


class CHeaderPlusEvasion(CDiscreteBytesEvasion):
	"""Creates the attack that perturbs the header of a Windows PE malware.
	"""

	def __init__(
			self,
			end2end_model: CDiscreteBytesEvasion,
			index_to_perturb: list = None,
			iterations: int = 100,
			is_debug: bool = False,
			random_init: bool = False,
			header_and_padding: bool = False,
			threshold: float = 0,
			penalty_regularizer: int = 0,
			how_many: int = 144,
			byte_change: list = None
	):
		"""
		Creates the evasion object

		Parameters
		----------
		end2end_model : CClassifierEnd2EndMalware
			the target end-to-end model
		index_to_perturb : list
			a list containing the index to perturb inside the samples
		byte_change : list
			a list containing the changed byte value
		iterations : int, optional, default 100
			the number of iterations of the optimizer
		is_debug : bool, optional, default False
			if True, prints debug information during the optimization
		random_init : bool, optional, default False
			if True, it randomizes the locations set by index_to_perturb before starting the optimization
		optimize_all_dos : bool, optional, default False
			if True, set as editable all the DOS header, not only the specified portion
		threshold : float, optional, default 0
			the detection threshold to bypass. Default is 0
		penalty_regularizer : float
			the reularization parameter, Default is 0
		how_many : int
			how many padding byte to inject, Default is 144
		"""

		if index_to_perturb is None:
			index_to_perturb = [i for i in range(2, 0x3C)]



		super(CHeaderPlusEvasion, self).__init__(
			end2end_model,
			index_to_perturb,
			iterations,
			is_debug,
			random_init,
			threshold,
			penalty_regularizer,
		)
		self.header_and_padding = header_and_padding
		self.how_many_padding_bytes = how_many
		self.byte_change = byte_change

	def _set_dos_indexes(self, x_init):
		if self.header_and_padding:
			# pe_position = x_init[0x3C:0x40].tondarray().astype(np.uint16)[0]
			# if self.shift_values:
			# 	pe_position = np.array([p - 1 for p in pe_position])
			# pe_position = struct.unpack("<I", bytes(pe_position.astype(np.uint8)))[0]

			# header 58 + padding 144 = 202
			invalid_value = 256 if self.invalid_pos == -1 else self.invalid_pos
			padding_positions = x_init.find(x_init == invalid_value)
			if not padding_positions:
				self.indexes_to_perturb = [i for i in range(2, 0x3C)]
			else:
				self.indexes_to_perturb = [i for i in range(2, 0x3C)] + list(range(
						padding_positions[0],
						min(x_init.size, padding_positions[0] + self.how_many_padding_bytes)
					))
			self._how_many = len(self.indexes_to_perturb)
			if self.is_debug:
				print(f"perturbing {self._how_many}")




	def _run(self, x0, y0, x_init=None):
		self._set_dos_indexes(x_init)

		return super(CHeaderPlusEvasion, self)._run(x0, y0, x_init)
